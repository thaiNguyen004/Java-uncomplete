    Như đã đề cập, thường thì bạn muốn luồng chính kết thúc cuối cùng. Trong các ví dụ trước đó, 
điều này được thực hiện bằng cách gọi hàm sleep() trong hàm main(), với độ trễ đủ lớn để đảm bảo 
tất cả các luồng con kết thúc trước luồng chính. Tuy nhiên, đây không phải là một giải pháp 
đáp ứng được và nó cũng đặt ra một câu hỏi lớn hơn: 

Làm thế nào một luồng có thể biết khi một luồng khác đã kết thúc?

    May mắn thay, Thread cung cấp một cách để bạn có thể trả lời câu hỏi này. 
Có hai cách để xác định xem một luồng đã kết thúc hay chưa. 
Trước tiên, bạn có thể gọi isAlive() trên luồng đó. Phương thức này được định nghĩa bởi lớp Thread, 
và dạng tổng quát của nó được hiển thị ở đây: 

    final boolean isAlive()

Phương thức isAlive() trả về true nếu luồng mà nó được gọi đến vẫn đang chạy. Nó trả về false nếu không còn chạy nữa.

Mặc dù isAlive() đôi khi hữu ích, phương thức mà bạn sẽ sử dụng thường xuyên hơn 
để đợi một luồng kết thúc được gọi là join(). 

Phương thức này đợi đến khi luồng mà nó được gọi đến kết thúc. Tên của nó xuất phát từ 
khái niệm của luồng gọi đợi cho đến khi luồng được chỉ định kết nối với nó. 
Các dạng bổ sung của join() cho phép bạn chỉ định một khoảng thời gian tối đa mà bạn muốn đợi 
cho luồng được chỉ định kết thúc.
Dưới đây là một phiên bản cải tiến của ví dụ trước đó sử dụng join() để đảm bảo rằng 
luồng chính là luồng cuối cùng dừng lại. Nó cũng thể hiện phương thức isAlive().


